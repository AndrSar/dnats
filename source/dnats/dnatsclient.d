/*
    Copyright (C) 2017 Andrey Lifanov

    Boost Software License - Version 1.0 - August 17th, 2003

    Permission is hereby granted, free of charge, to any person or organization
    obtaining a copy of the software and accompanying documentation covered by
    this license (the "Software") to use, reproduce, display, distribute,
    execute, and transmit the Software, and to prepare derivative works of the
    Software, and to permit third-parties to whom the Software is furnished to
    do so, all subject to the following:

    The copyright notices in the Software and this entire statement, including
    the above license grant, this restriction and the following disclaimer,
    must be included in all copies of the Software, in whole or in part, and
    all derivative works of the Software, unless such copies or derivative
    works are solely in the form of machine-executable object code generated by
    a source language processor.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
    SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
    FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.

*/

/**
 * An asynchronous client library for NATS Server.
 * From $(http://nats.io/, NATS official site):
 *     NATS Server is a simple, high performance open source messaging system
 *     for cloud native applications, IoT messaging, and microservices architectures.
 * Version: 1.0.0-beta
 * License: $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Andrey Lifanov.
 */

module dnats.dnatsclient;

enum __version__ = "1.0.0-beta";

import std.socket;
import std.json;
import core.time;
import core.thread;
import std.string;
import std.outbuffer;

import std.container.dlist;
import std.container : clear;
import std.conv : to;

debug
{
    import std.stdio;
}


/**
* Requires NATS server to be running. 
*/

unittest
{
    auto clientAThread = new Thread({
        auto client = new NATSClient();

        // Connect with default settings:
        client.connect((in ServerInfo serverInfo){
            client.publish("COMMON", "Hello!");
        });

        Thread.sleep(dur!("msecs")(300)); // Wait for subscriber
        client.processIOEvents(); // run once
    });

    auto clientBCThread = new Thread({
        auto clientB = new NATSClient();
        auto clientC = new NATSClient();

        bool messageBReceived = false;
        bool messageCReceived = false;

        void onConnectB(in ServerInfo serverInfo)
        {
            clientB.subscribe("COMMON", "SUBS1", (in NATSMessage msg){
                messageBReceived = true;
                assert(msg.subject == "COMMON");
                assert(msg.msg == "Hello!");
            });
        }

        void onConnectC(in ServerInfo serverInfo)
        {
            clientC.subscribe("COMMON", "SUBS1", (in NATSMessage msg){
                messageCReceived = true;
                assert(msg.subject == "COMMON");
                assert(msg.msg == "Hello!");
            });
        }

        clientB.connect(&onConnectB);
        clientC.connect(&onConnectC);

        // Wait for message from publisher
        // Processing multiple clients in one thread:
        runIOLoop([clientB, clientC], ()=>messageBReceived && messageCReceived);

        assert(messageBReceived && messageCReceived);
    });

    clientAThread.start();
    clientBCThread.start();
    clientAThread.join();
    clientBCThread.join();
}


/**
* Request/reply example.
*/

unittest
{
    shared bool replyReceived = false;

    auto clientRequestThread = new Thread({
        auto client = new NATSClient();

        client.connect((in ServerInfo serverInfo){
            client.request("api.version", "replyToMe", [], "SID1", (in NATSMessage msg)
                {
                    replyReceived = true;
                    assert(msg.msg == "1.0.0");
                });
        });

        client.runIOLoop(()=>replyReceived);
    });

    auto clientReplyThread = new Thread({
        auto client = new NATSClient();

        void onConnect(in ServerInfo serverInfo)
        {
            client.reply("api.version", "", "SID1", (in void[] data){
                return "1.0.0";
            });
        }

        client.connect(&onConnect);

        client.runIOLoop(()=>replyReceived);
    });

    clientReplyThread.start();
    Thread.sleep(dur!("msecs")(300));
    clientRequestThread.start();
    clientRequestThread.join();
    clientReplyThread.join();
}


interface NATSProtocolMessage
{
    string type() const;
}

interface NATSProtocolIncomingMessage : NATSProtocolMessage
{
    void parseHeader(in char[] str);
    ptrdiff_t parseData(in void[] data);
    typeof(this) clone() const;
    void callHandler(NATSClient natsClient) const;
}

interface NATSProtocolOutgoingMessage : NATSProtocolMessage
{
    void serialize(OutBuffer buffer) const;
}


final class NATSProtocolInfoMessage : NATSProtocolIncomingMessage
{
    string serverId;
    string _version;
    string go;
    string host;
    ushort port;
    bool authRequired;
    bool sslRequired;
    long maxPayload;

    private this()
    {
    }

    override string type() const
    {
        return "INFO";
    }

    override void parseHeader(in char[] str)
    {
        fromJSONString(str[type().length + 1..$]);
    }

    override ptrdiff_t parseData(in void[] data)
    {
        return 0;
    }

    override void callHandler(NATSClient natsClient) const
    {
        natsClient.onINFO(this);
    }

    override NATSProtocolIncomingMessage clone() const
    {
        return new NATSProtocolInfoMessage();
    }

    private void fromJSONString(in char[] str)
    {
        JSONValue j = parseJSON(str);
        serverId = j["server_id"].str;
        _version = j["version"].str;
        go = j["go"].str;
        host = j["host"].str;
        port = cast(ushort)j["port"].integer;
        authRequired = j["auth_required"].type == JSON_TYPE.TRUE;
        sslRequired = j["ssl_required"].type == JSON_TYPE.TRUE;
        maxPayload = j["max_payload"].integer;
    }
}


final class NATSProtocolPingMessage : NATSProtocolIncomingMessage, NATSProtocolOutgoingMessage
{
    private this()
    {
    }

    override string type() const
    {
        return "PING";
    }

    override void parseHeader(in char[] str)
    {
    }

    override ptrdiff_t parseData(in void[] data)
    {
        return 0;
    }

    override void callHandler(NATSClient natsClient) const
    {
        natsClient.onPING();
    }

    override NATSProtocolIncomingMessage clone() const
    {
        return new NATSProtocolPingMessage();
    }

    override void serialize(OutBuffer buffer) const
    {
        buffer.write("PING\r\n");
    }
}


final class NATSProtocolPongMessage : NATSProtocolOutgoingMessage, NATSProtocolIncomingMessage
{
    private this()
    {
    }

    override string type() const
    {
        return "PONG";
    }

    override void parseHeader(in char[] str)
    {
    }

    override ptrdiff_t parseData(in void[] data)
    {
        return 0;
    }

    override void callHandler(NATSClient natsClient) const
    {
        
    }

    override NATSProtocolIncomingMessage clone() const
    {
        return new NATSProtocolPongMessage();
    }

    override void serialize(OutBuffer buffer) const
    {
        buffer.write("PONG\r\n");
    }
}


final class NATSProtocolConnectMessage : NATSProtocolOutgoingMessage
{
    this()
    {
    }

    this(string name)
    {
        this.name = name;
    }

    void setUserPass(string user, string pass)
    {
        this.user = user;
        this.pass = pass;
    }

    @property
    bool pedantic() const
    {
        return _pedantic;
    }

    @property
    void pedantic(bool state)
    {
        _pedantic = state;
    }

    override string type() const
    {
        return "CONNECT";
    }

    override void serialize(OutBuffer buffer) const
    {
        JSONValue j;
        j["verbose"] = verbose;
        j["pedantic"] = pedantic;
        if (!user.empty)
        {
            j["user"] = user;
            j["pass"] = pass;
        }
        j["name"] = name;
        j["protocol"] = protocol;
        j["lang"] = lang;
        j["version"] = _version;

        buffer.write(type());
        buffer.write(' ');
        buffer.write(j.toString());
        buffer.write("\r\n");
    }

private:
    bool verbose = false;
    bool _pedantic = false;
    string name = "DNatsClient";
    string lang = "D";
    string _version = __version__;
    int protocol = 0;
    string user;
    string pass;
}


unittest
{
    import std.algorithm : canFind, startsWith, endsWith;
    
    OutBuffer outBuffer = new OutBuffer;
    auto options = new NATSProtocolConnectMessage("Client");
    options.setUserPass("user", "pass");
    options._version = "1.0.0";
    options.serialize(outBuffer);

    const(char)[] str = cast(char[])outBuffer.toBytes();

    assert(startsWith(str, "CONNECT "));
    assert(endsWith(str, "\r\n"));

    assert(canFind(str,"\"verbose\":false"));
    assert(canFind(str,"\"pedantic\":false"));
    assert(canFind(str,"\"user\":\"user\""));
    assert(canFind(str,"\"pass\":\"pass\""));
    assert(canFind(str,"\"name\":\"Client\""));
    assert(canFind(str,"\"lang\":\"D\""));
    assert(canFind(str,"\"version\":\"1.0.0\""));
    assert(canFind(str,"\"protocol\":0"));
}


class NATSProtocolPubMessage : NATSProtocolOutgoingMessage
{
    this(string subject, string reply, const(void)[] data)
    {
        this.subject = subject;
        this.reply = reply;
        this.data = data;
    }

    override string type() const
    {
        return "PUB";
    }

    override void serialize(OutBuffer buffer) const
    {
        buffer.write("PUB ");
        buffer.write(subject);
        buffer.write(' ');
        if (!reply.empty())
        {
            buffer.write(reply);
            buffer.write(' ');
        }
        buffer.write(to!string(data.length));
        buffer.write("\r\n");
        buffer.write(cast(ubyte[])data);
        buffer.write("\r\n");
    }

    ~this()
    {
        data = null;
    }

private:
    string subject;
    string reply;
    const(void)[] data;
}


final class NATSProtocolSubMessage : NATSProtocolOutgoingMessage
{
    this(string subject, string group, string sid)
    {
        this.subject = subject;
        this.queueGroup = group;
        this.sid = sid;
    }

    override string type() const
    {
        return "SUB";
    }

    override void serialize(OutBuffer buffer) const
    {
        buffer.write(type());
        buffer.write(' ');
        buffer.write(subject);
        buffer.write(' ');
        if (!queueGroup.empty())
        {
            buffer.write(queueGroup);
            buffer.write(' ');
        }
        buffer.write(sid);
        buffer.write("\r\n");
    }

private:
    string subject;
    string queueGroup;
    string sid;
}


unittest
{
    auto subMsg = new NATSProtocolSubMessage("COMMON", "1", "SUBS1");
    OutBuffer outBuffer = new OutBuffer;
    subMsg.serialize(outBuffer);
    assert(cast(char[])outBuffer.toBytes() == "SUB COMMON 1 SUBS1\r\n");
}


final class NATSProtocolUnsubMessage : NATSProtocolOutgoingMessage
{
    this(string sid, uint maxMsgs = 0)
    {
        this.sid = sid;
        this.maxMsgs = maxMsgs;
    }

    override string type() const
    {
        return "UNSUB";
    }

    override void serialize(OutBuffer buffer) const
    {
        buffer.write(type());
        buffer.write(' ');
        buffer.write(sid);
        if (maxMsgs > 0)
        {
            buffer.write(' ');
            buffer.write(to!string(maxMsgs));
        }
        buffer.write("\r\n");
    }

private:
    string sid;
    uint maxMsgs;
}


final class NATSProtocolMsgMessage : NATSProtocolIncomingMessage
{
    string subject;
    string sid;
    string reply;
    const(void)[] payload;

    @property
    const(char)[] msg() const
    {
        return cast(const(char)[])payload;
    }

    private this()
    {
    }

    override string type() const
    {
        return "MSG";
    }

    override void parseHeader(in char[] str)
    {
        import std.algorithm : splitter;
        import std.conv : to;

        auto splitted = split(str[4..$]);
        this.subject = splitted[0].idup;
        this.sid = splitted[1].idup;
        const(char)[] thirdSlice = splitted[2];
        if (!thirdSlice.isNumeric())
        {
            this.reply = thirdSlice.idup;
        }
        this.expectedPayloadSize = splitted[$-1].to!size_t();

        if (expectedPayloadSize > 0)
            payload.reserve(expectedPayloadSize);
    }

    override ptrdiff_t parseData(in void[] data)
    {
        ptrdiff_t bytesParsed = 0;
        if (expectedPayloadSize > 0)
        {
            const size_t bytesLeft = expectedPayloadSize - payload.length;
            if (bytesLeft <= data.length)
            {
                payload ~= data[0..bytesLeft];
                bytesParsed = bytesLeft;
            }
            else
            {
                payload ~= data;
                bytesParsed = -1;
            }
        }

        return bytesParsed;
    }

    override void callHandler(NATSClient natsClient) const
    {
        natsClient.onMSG(this);
    }

    override NATSProtocolIncomingMessage clone() const
    {
        return new NATSProtocolMsgMessage();
    }

    ~this()
    {
        payload = null;
    }

private:
    size_t expectedPayloadSize = 0;
}


unittest
{
    {
        auto msg = new NATSProtocolMsgMessage();
        auto msgStrHeader = "MSG COMMON SUBS1 6";
        auto msgStrPayload = "Hello!\r\n";
        msg.parseHeader(msgStrHeader);
        auto bytesParsed = msg.parseData(msgStrPayload);
        assert(bytesParsed == msgStrPayload.length - 2);
        assert(msg.subject == "COMMON");
        assert(msg.sid == "SUBS1");
        assert(msg.msg == "Hello!");
    }

    {
        auto msg = new NATSProtocolMsgMessage();
        auto msgStrHeader = "MSG COMMON SUBS1 6";
        auto msgStrPayloadPart1 = "Hell";
        auto msgStrPayloadPart2 = "o!\r\n";
        msg.parseHeader(msgStrHeader);

        auto bytesParsed = msg.parseData(msgStrPayloadPart1);
        assert(bytesParsed == -1);

        bytesParsed = msg.parseData(msgStrPayloadPart2);
        assert(bytesParsed == 2);

        assert(msg.subject == "COMMON");
        assert(msg.sid == "SUBS1");
        assert(msg.msg == "Hello!");
    }

    {
        auto msg = new NATSProtocolMsgMessage();
        auto msgStrHeader = "MSG COMMON SUBS1 6";
        auto msgStrPayload = "";
        msg.parseHeader(msgStrHeader);
        auto bytesParsed = msg.parseData(msgStrPayload);
        assert(bytesParsed == -1);
        assert(msg.payload.length == 0);
    }
}


final class NATSProtocolOkMessage : NATSProtocolIncomingMessage
{
    private this()
    {
    }

    override string type() const
    {
        return "+OK";
    }

    override void parseHeader(in char[] str)
    {
    }

    override ptrdiff_t parseData(in void[] data)
    {
        return 0;
    }

    override void callHandler(NATSClient natsClient) const
    {
        natsClient.onOK();
    }

    override NATSProtocolIncomingMessage clone() const
    {
        return new NATSProtocolOkMessage();
    }
}


final private class NATSProtocolErrMessage : NATSProtocolIncomingMessage
{
    string msg;

    private this()
    {
    }

    override string type() const
    {
        return "-ERR";
    }

    override void parseHeader(in char[] str)
    {
        msg = str[type().length + 2..$-1].idup;
    }

    override ptrdiff_t parseData(in void[] data)
    {
        return 0;
    }

    override void callHandler(NATSClient natsClient) const
    {
        natsClient.onERR(this);
    }

    override NATSProtocolIncomingMessage clone() const
    {
        return new NATSProtocolErrMessage();
    }
}


unittest
{
    auto msg = new NATSProtocolErrMessage();
    auto msg_str = "-ERR 'Authorization Violation'";
    msg.parseHeader(msg_str);
    assert(msg.msg == "Authorization Violation");
}


private class NATSProtocolIncomingMessagesFactory
{
    this()
    {
        NATSProtocolIncomingMessage msgMessage = new NATSProtocolMsgMessage();
        NATSProtocolIncomingMessage infoMessage = new NATSProtocolInfoMessage();
        NATSProtocolIncomingMessage pingMessage = new NATSProtocolPingMessage();
        NATSProtocolIncomingMessage okMessage = new NATSProtocolOkMessage();
        NATSProtocolIncomingMessage errMessage = new NATSProtocolErrMessage();
        prototypes = [msgMessage, infoMessage, pingMessage, okMessage, errMessage]; // order is important!
    }

    NATSProtocolIncomingMessage produce(in char[] str)
    {
        size_t i = str.startsWith("MSG", "INFO", "PING", "+OK", "-ERR"); // order is important!
        if (i > 0)
        {
            return prototypes[i - 1].clone(); 
        }

        return null;
    }

private:
    NATSProtocolIncomingMessage[] prototypes;
}


unittest
{
    auto factory = new NATSProtocolIncomingMessagesFactory;
    auto msgStr = "MSG 123";
    auto infoStr = "INFO {456}";
    auto pingStr = "PING\r\n";
    auto okStr = "+OK";
    auto errStr = "-ERR 'Error'";

    assert(factory.produce(msgStr).type() == "MSG");
    assert(factory.produce(infoStr).type() == "INFO");
    assert(factory.produce(pingStr).type() == "PING");
    assert(factory.produce(okStr).type() == "+OK");
    assert(factory.produce(errStr).type() == "-ERR");
}


alias ConnectionOptions = NATSProtocolConnectMessage;
alias ServerInfo = NATSProtocolInfoMessage;
alias NATSMessage = NATSProtocolMsgMessage;
alias ErrMessage = NATSProtocolErrMessage; 


class NATSClient
{
    alias ConnectDelegate = void delegate(in ServerInfo);
    alias SubscriptionDelegate = void delegate(in NATSMessage);
    alias ReplyDelegate = const(void)[] delegate(in void[]);
    alias ServerErrorDelegate = void delegate(in ErrMessage);

    enum outBufferDedaultSize = 8 * 4096;
    enum inBufferDefaultSize = 8 * 4096;
    

    this(in char[] hostname = "127.0.0.1", ushort port = 4222)
    {
        address = getAddress(hostname, port)[0];
        incomingMessagesFactory = new NATSProtocolIncomingMessagesFactory();
        serverErrorDelegate = &onServerErrorDefaultAction;
    }

    void connect(ConnectDelegate onConnection)
    {
        this._connect(new ConnectionOptions, onConnection);
    }

    void connect(ConnectionOptions options, ConnectDelegate onConnection)
    {
        this._connect(options, onConnection);
    }

    void connect(in char[] hostname, ushort port,
                 ConnectionOptions options,
                 ConnectDelegate onConnection)
    {
        address = getAddress(hostname, port)[0];
        this._connect(options, onConnection);
    }

    void publish(string subject, const(void)[] data)
    in
    {
        assert(isConnected);
        assert(!subject.empty());
    }
    body
    {
        enqueueOutgoingMessage(new NATSProtocolPubMessage(subject, "", data));
    }

    void request(string subject, string replyTo, const(void)[] data)
    in
    {
        assert(isConnected);
        assert(!subject.empty());
    }
    body
    {
        enqueueOutgoingMessage(new NATSProtocolPubMessage(subject, replyTo, data));
    }

    void request(string subject, string replyTo, const(void)[] data, string sid, SubscriptionDelegate subscriptionDelegate)
    {
        //string sid = subject ~ "ReplySid";
        //string replyTo = subject ~ "Reply";

        if (sid !in subscriptions)
        {
            subscribe(replyTo, sid, subscriptionDelegate);
        }

        request(subject, replyTo, data);
    }

    void subscribe(string subject, string sid, SubscriptionDelegate subscriptionDelegate)
    {
        subscribe(subject, "", sid, subscriptionDelegate);
    }

    void subscribe(string subject, string group, string sid, SubscriptionDelegate subscriptionDelegate)
    in
    {
        assert(isConnected);
        assert(!subject.empty);
        assert(!sid.empty);
        assert(subscriptionDelegate !is null);
        assert(!(sid in subscriptions));
    }
    body
    {
        putOutgoingMessageToBuffer(new NATSProtocolSubMessage(subject, group, sid));
        subscriptions[sid] = subscriptionDelegate;
    }

    void reply(string subject, string group, string sid, ReplyDelegate replyDelegate)
    in
    {
        assert(isConnected);
        assert(!subject.empty);
        assert(!sid.empty);
        assert(replyDelegate !is null);
        assert(!(sid in replySubscriptions));
    }
    body
    {
        putOutgoingMessageToBuffer(new NATSProtocolSubMessage(subject, group, sid));
        replySubscriptions[sid] = replyDelegate;
    }

    void unsubscribe(string sid, uint maxMsgs = 0)
    in
    {
        assert(isConnected);
        assert(!sid.empty);
        assert(sid in subscriptions);
    }
    body
    {
        subscriptions.remove(sid);
        putOutgoingMessageToBuffer(new NATSProtocolUnsubMessage(sid, maxMsgs));
    }


    void runIOLoop(bool delegate() stopCondition, in Duration sleepDuration = msecs(2))
    {
        import std.datetime.stopwatch;

        auto sw = StopWatch(AutoStart.yes);

        while (!stopCondition())
        {
            sw.reset();

            try
            {
                processIOEvents();
            }
            catch (NATSServerException e)
            {
                continue;
            }

            const Duration elapsedTime = sw.peek();
            if (elapsedTime < sleepDuration)
            {
                Thread.sleep(sleepDuration - elapsedTime);
            }
        }
    }


    void processIOEvents(Duration socketEventsTimeout = msecs(5))
    {
        const int status = TcpSocket.select(socketSetRead, socketSetWrite, socketSetError, socketEventsTimeout);

        if (status >= 0)
        {
            if (socketSetRead.isSet(socket))
            {
                this.receiveData();
                this.processIncomingMessages();
            }
            else
            {
                socketSetRead.add(socket);
            }

            if (socketSetWrite.isSet(socket))
            {
                this.sendData();
            }
            else
            {
                socketSetWrite.add(socket);
            }

            if (socketSetError.isSet(socket))
            {
                debug
                {
                    writeln("Select socket error.");
                }
            }
            else
            {
                socketSetError.add(socket);
            }
        }
        else
        {
            debug
            {
                writeln("Select socket status: ", status);
            }
        }
    }

    void disconnect()
    {
        if (socket !is null && socket.isAlive())
        {
            socket.shutdown(SocketShutdown.BOTH);
            socket.close();
        }
        isConnectedFlag = false;
        subscriptions = null;
    }

    void onServerError(ServerErrorDelegate d)
    {
        serverErrorDelegate = d;
    }

    @property
    bool isConnected() const
    {
        return isConnectedFlag;
    }

    @property
    ulong totalMessagesReceived() const
    {
        return totalMessagesReceivedCounter;
    }

    @property
    ulong totalMessagesSent() const
    {
        return totalMessagesSentCounter;
    }

    ~this()
    {
        disconnect();
        socket = null;
    }

private:
    void _connect(ConnectionOptions options, ConnectDelegate onConnection)
    in
    {
        assert(options !is null);
        assert(onConnection !is null);
    }
    body
    {
        connectionOptions = options;
        connectDelegate = onConnection;

        socket = new TcpSocket();
        socket.blocking = false;
        socketSetRead = new SocketSet(1);
        socketSetRead.add(socket);
        socketSetWrite = new SocketSet(1);
        socketSetWrite.add(socket);
        socketSetError = new SocketSet(1);
        socketSetError.add(socket);
        inBuffer = new char[inBufferReservedSize];
        outBuffer = new OutBuffer();
        outBuffer.reserve(outBufferReservedSize);
        socket.connect(address);
        putOutgoingMessageToBuffer(connectionOptions);
    }


    void receiveData()
    {
        const ptrdiff_t bytesReadFromSocket = socket.receive(inBuffer[offsetFromPrevRead..$]);

        if (bytesReadFromSocket < 0)
        {
            throw new NATSClientException(socket.getErrorText());
            return;
        }
        else if (bytesReadFromSocket == 0)
        {
            isConnectedFlag = false;
        }

        const size_t inBufferEnd = bytesReadFromSocket + offsetFromPrevRead;
        offsetFromPrevRead = 0;
        size_t totalBytesParsed = 0;

        debug
        {
            writeln("Bytes received: ", bytesReadFromSocket);
            writeln(inBuffer[0..inBufferEnd]);
        }

        readloop:
        while(totalBytesParsed < inBufferEnd)
        {
            NATSProtocolIncomingMessage message;
            const(char)[] bufferSlice = inBuffer[totalBytesParsed..inBufferEnd];

            if (incompleteIncomingMessage is null)
            {
                const ptrdiff_t newLineIndex = bufferSlice.indexOf("\r\n");

                if (newLineIndex > 0)
                {
                    const(char)[] header = bufferSlice[0..newLineIndex];
                    debug(2)
                    {
                        writeln("Parsing header: ", header);
                    }

                    if (header[0] == '\n')
                    {
                        totalBytesParsed += 1;
                        header = header[1..$];
                    }

                    message = incomingMessagesFactory.produce(header);

                    if (message !is null)
                    {
                        message.parseHeader(header);
                        totalBytesParsed += newLineIndex + 2;
                        bufferSlice = inBuffer[totalBytesParsed..inBufferEnd];
                    }
                    else
                    {
                        throw new NATSClientException(
                            "Couldn't produce message due to unknown message type. String passed:\n" ~ header.idup);
                        break readloop;
                    }   
                }
                else if (newLineIndex == 0)
                {
                    totalBytesParsed += 2;
                    continue readloop;
                }
                else // safe for the next receive iteration what is left unparsed
                {
                    for (size_t i = 0; i < bufferSlice.length; ++i)
                    {
                        inBuffer[i] = bufferSlice[i];
                    }
                    offsetFromPrevRead = bufferSlice.length;
                    break readloop;
                }
            }
            else
            {
                message = incompleteIncomingMessage;
            }
            
            const ptrdiff_t messageDataBytesParsed = message.parseData(bufferSlice);

            if (messageDataBytesParsed >= 0) // message was parsed
            {
                totalBytesParsed += messageDataBytesParsed;
                incompleteIncomingMessage = null;
                inBoxQueue.insertBack(message);
            }
            else
            {
                incompleteIncomingMessage = message;
                break readloop;
            }
        }
    }


    void processIncomingMessages()
    {
        foreach (message; inBoxQueue)
        {
            message.callHandler(this);
        }

        inBoxQueue.clear();
    }


    void sendData()
    {
        if (outBoxQueue.empty && outBuffer.offset == 0)
        {
            return;
        }

        size_t dropCount = 0;
        foreach (message; outBoxQueue)
        {
            dropCount += 1;
            message.serialize(outBuffer);
            if (outBuffer.offset >= outBufferReservedSize)
            {
                break;
            }
        }

        const(void)[] actualBufferData = outBuffer.toBytes();
        const size_t length = actualBufferData.length;

        debug
        {
            writeln("Sendind data:");
            writeln(cast(const(char)[])actualBufferData);
        }

        size_t bytesSent = 0;
        while (bytesSent < length)
        {
            const ptrdiff_t sendStatus = socket.send(actualBufferData[bytesSent..$]);
            if (sendStatus > 0)
            {
                bytesSent += sendStatus;
            }
            else
            {
                throw new NATSClientException(socket.getErrorText());
            }
        }

        totalMessagesSentCounter += dropCount;
        outBoxQueue.removeFront(dropCount);
        outBuffer.offset = 0;
    }

    void onINFO(in ServerInfo message)
    {
        isConnectedFlag = true;
        connectDelegate(message);
    }

    void onMSG(in NATSProtocolMsgMessage message)
    {
        ++totalMessagesReceivedCounter;

        auto replyDelegate = message.sid in replySubscriptions;
        if (replyDelegate is null)
        {
            subscriptions[message.sid](message);
        }
        else
        {
            publish(message.reply, (*replyDelegate)(message.payload));
        }
    }

    void onPING()
    {
        debug
        {
            writeln("PING");
        }
        putOutgoingMessageToBuffer(new NATSProtocolPongMessage);
    }

    void onPONG()
    {

    }

    void onOK()
    {

    }

    void onERR(in NATSProtocolErrMessage message)
    {
        serverErrorDelegate(message);

        if (message.msg == "Invalid Subject" ||
            message.msg.startsWith("Permissions Violation for Subscription") ||
            message.msg.startsWith("Permissions Violation for Publish "))
        {
            throw new NATSServerException(message.msg);
        }
        else
        {
            this.disconnect();
            throw new NATSServerUnrecoverableException(message.msg);
        }
    }

    void enqueueOutgoingMessage(NATSProtocolOutgoingMessage message)
    {
        outBoxQueue.insertBack(message);
    }

    void putOutgoingMessageToBuffer(NATSProtocolOutgoingMessage message)
    {
        message.serialize(outBuffer);
    }

    void onServerErrorDefaultAction(in ErrMessage msg)
    {
        debug
        {
            writeln("Server error: ", msg.msg);
        }
    }

private:
    bool isConnectedFlag = false;
    Address address;
    ConnectionOptions connectionOptions;
    TcpSocket socket;
    char[] inBuffer;
    size_t offsetFromPrevRead = 0;
    OutBuffer outBuffer;
    size_t inBufferReservedSize = inBufferDefaultSize;
    size_t outBufferReservedSize = outBufferDedaultSize;
    SocketSet socketSetRead;
    SocketSet socketSetWrite;
    SocketSet socketSetError;
    DList!NATSProtocolIncomingMessage inBoxQueue;
    DList!NATSProtocolOutgoingMessage outBoxQueue;
    NATSProtocolIncomingMessage incompleteIncomingMessage;
    NATSProtocolIncomingMessagesFactory incomingMessagesFactory;

    ulong totalMessagesSentCounter;
    ulong totalMessagesReceivedCounter;

    ConnectDelegate connectDelegate;
    ServerErrorDelegate serverErrorDelegate;
    SubscriptionDelegate[string] subscriptions;
    ReplyDelegate[string] replySubscriptions;
}


void runIOLoop(NATSClient[] clients, bool delegate() stopCondition, in Duration sleepDuration = msecs(5))
in
{
    assert(!clients.empty);
}
body
{
    import std.datetime.stopwatch;

    auto sw = StopWatch(AutoStart.yes);

    while (!stopCondition())
    {
        sw.reset();

        try
        {
            foreach (client; clients)
                client.processIOEvents();
        }
        catch (NATSServerException e)
        {
            continue;
        }

        const Duration elapsedTime = sw.peek();
        if (elapsedTime < sleepDuration)
        {
            Thread.sleep(sleepDuration - elapsedTime);
        }
    }
}


class NATSClientException : Exception
{
    this(string msg)
    {
        super(msg);
    }
}


class NATSServerException : Exception
{
    this(string msg)
    {
        super(msg);
    }
}


class NATSServerUnrecoverableException : Exception
{
    this(string msg)
    {
        super(msg);
    }
}


class NATSUnknownProtocolMessageTypeException : NATSClientException
{
    this()
    {
        super("Unknown protocol message type");
    }
}